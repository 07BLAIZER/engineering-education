---
layout: engineering-education
status: publish
published: true
url: /engineering-education/performance-optimization-techniques-for-node-js/
title: Performance Optimization tips for Node.js Applications
description: This article covers performance optimization techniques, tools, and tips to make high-performing Node.js apps.
author: joseph-chege
date: 2020-09-22T00:00:00-14:00
topics: []
excerpt_separator: <!--more-->
images:		
  - url: /engineering-education/performance-optimization-techniques-for-node-js/hero.jpg
    alt: Performance optimization tips Node.js
---
Performance is an important aspect when building webpages and applications. When developing applications, you need to understand how long your users interact with your app, how often they leave, and the response time as well.
<!--more-->

The first 10 seconds are vital to determine if a user will leave or continue interacting with your web pages. In addition, you must clearly speed up the page and bring value within these 10 seconds and get the user's attention to spend more time on your page.

This is where optimizing your page and speeding up the response time becomes important for your users experience. Node.js is known to produce super-fast performing and scalable web applications with an event-driven architecture and non-blocking (asynchronous) tasks that run on a single thread.

As a developer, you need your application to be fast and fully optimized. One could say that Node.js is the fire and performance optimization is the gasoline, imagine how blazing fast your app could be. This article will cover techniques, tools, and tips to optimize Node.js apps and achieve higher-performance.

### Asynchronous coding
Node.js is designed with single thread concurrency architectures with non-blocking operations. Asynchronous is heavily used in Node.js to ensure a non-blocking operational flow. Asynchronous I/O permits other processing to continue even before the first transmission has finished. Synchronous coding can potentially lock your web page, it uses blocking operations that might block your main thread and this will drastically reduce your web page performance.

Asynchronous coding will allow you to use queues to monitor your workflow, allowing you to append additional tasks and add extra callbacks without blocking your main thread. Even though you may try to use Asynchronous methods, in some instances, it is possible to find your web page making some blocking calls. This is common when using third-party modules, you should keep an eye on the external libraries you are using and take precautions to avoid them dominating with synchronous calls.

Take a look at the example below: We used the file read operation in both models [using Node.js file system](https://nodejs.dev/learn/the-nodejs-fs-module)

#### Synchronous
```js
var fs = require('fs');
var content = fs.readFileSync("app.js", "utf8");
console.log(content);
console.log('waiting for the file to read.........');
```

![Synchronous](/engineering-education/performance-optimization-techniques-for-node-js/synchronous.png)

#### Asynchronous
```js
//inlude file system module
var fs = require('fs');
//readFile() reads the file
fs.readFile("app.js", "utf8", function (err, content) {
    if (err) {
        return console.log(err);
    }
    //read the file
    console.log(content);
});
console.log('waiting for the file to read.....');
```

![Asynchronous](/engineering-education/performance-optimization-techniques-for-node-js/asynchronous.png)

With the synchronous snippet, all processes are paused until the file reading is over. The `readFileSync()` will first read the file and store its data in the memory before printing the data and message in the console.

Asynchronous will print the console message as the system performs other tasks. The "waiting for the file to read" is printed before the file content even though it was the last command. A callback function will be called when the file reading is done. The asynchronous model will have faster execution of our program and avoid the so-called "Call-back Hell".

### Query optimization
Just imagine having more than one million rows of data to query from your database table, the process generated by this database to get the endpoint of this data will greatly affect your application performance, and displaying this data can make it even slower. Using bad queries will make your application almost useless (and will leave your users dissatisfied). The solution to this is to perform a query optimization.

#### Basic tips to improve your database performance/[optimization overview](https://dev.mysql.com/doc/refman/8.0/en/optimize-overview.html)

- Database and table indexing/structure. Proper [indexing](https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html) will speed up data retrieval between your databases and tables to select and sort rows faster. Proper indexing will help you avoid columns from overlapping.

- Avoid [SELECT](https://dev.mysql.com/doc/refman/8.0/en/select-optimization.html)

This would be the most obvious thing you would use to select your columns, right? Yet, you should not overlook how cumbersome this query can be, to list down columns you have in a table. Go for a more distinct approach using the SELECT statement to query only the data you need and avoid extra fetching loads to your database.

- Use the [clause WHERE](https://dev.mysql.com/doc/refman/8.0/en/where-optimization.html)

The goal of the query is to pull the required records from your database. WHERE clause helps to filter the records and limits the number of records to be pulled based on conditions. WHERE replaces the HAVING clause that selects records before filtering the dataset. In SQL operations, WHERE statements are faster as it reduces that data being processed by the database engine.

- [Use LIMIT](https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html) to sample the query results

LIMIT will return only the specified number of records. While using LIMIT, ensure that the results are desirable and meaningful when a limit is imposed on the dataset.

- To avoid columns use [text joins](https://dev.mysql.com/doc/internals/en/optimizer-joins.html)

Joins with strings/tests are considered much slower when compared to numeric columns. The solution to this is to always make sure foreign key strings have an equivalent numeric representation where join can be performed.

Here is an example:

```sql
SELECT from cars
WHERE color = 'red'
```
```sql
SELECT from cars
WHERE color_id = 2
```

The second query will execute faster than the first query due to the numeric representation.

- Running queries during off-peak hours

In the production database, analytical and database management queries should be executed when the concurrent users are at their lowest peak. Typically at night around 3 to 5 am.

#### Other Tips
- Avoid SELECT DISTRICT
- Statements such as [INSERT](https://dev.mysql.com/doc/refman/8.0/en/insert-optimization.html) and [UPDATE](https://dev.mysql.com/doc/refman/8.0/en/update-optimization.html) should be well optimized
- Avoid sub-optimal queries as they execute row by row which slows down your engine
- [Table optimazition](https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html)
- [Sub query optimation](https://dev.mysql.com/doc/refman/8.0/en/optimizing-subqueries.html)
- Use wildcard (%) character appropriately
- Avoid over normalization and use numeric for primary keys
- Avoid looping statements looping queries will slow your sequence

### Caching
A cache is a memory buffer where frequently accessed data is temporarily stored (data that will not be changed in the near future) in order to be accessed more quickly. Cached data is then retrieved without having to access the origin. Caching will improve your app response time and even reduce some costs such as bandwidth and data volumes.

Catching is a great practice to improve your app performance. If you have a fewer number of users, your app performance may not be greatly affected. However, performance problems may arise when the traffic grows and you need to maintain the load balance. When this happens, caching your app regularly will be a great technique to achieve higher-performance. Caching can be a little bit hard thus you need tools to cache your app efficiently such as:

- [Redis cache](https://redis.io/topics/client-side-caching) it is entirely asynchronous with optimal performance to handle cached data requests in a single thread. Consider checking it out, it is a smooth API that will help you manage your client-side and server-side cache.
- [Memcached](https://memcached.org/) stores data across different nodes with a hashing schema that provides a hash table functionality in a way that adding or removing a server node does not significantly change the [mapping of the keys to server nodes](https://npm.runkit.com/memcached).
- [Node-cache](https://www.npmjs.com/package/node-cache) works almost like Memcached with the set, get, and delete methods. It has a timeout that deletes data from the cache when the time out expires.
- [Nginx](https://docs.nginx.com/nginx/deployment-guides/load-balance-third-party/node-js/#configuring-content-caching) will help maintain load balance. Nginx will help cache static files, that will drastically offload the work of the application server. It offers low memory usage and high concurrency.

### Go session free
Session data is stored in memory. As traffic in your app grows, more sessions will be generated and this might add significant overhead to your server. You need to find a means to store session data or minimize the amount of data stored in the session. Modules such as [Express.js](https://expressjs.com/) can help you create server protocols that are stateless. Stateless protocols do not save or store any information from previous visits.

Switch to an external session store such as [Redis](https://redis.io/documentation), [Nginx](https://docs.nginx.com/nginx/deployment-guides/load-balance-third-party/node-js/#configuring-basic-session-persistence), [MongoDB](https://docs.mongodb.com/manual/reference/method/Session/). Whenever possible, the best option would be to store no session state on your server-side and you should get better performance.

### Script tracing and logging
Logging helps to track your application activities and traffic. When an app is running there might be possibilities to get fatal errors(even though your app is running properly after production testing), and you need to get this feedback in a timely manner, find out what code has the error(s), and fix them even before your user notices that something is faulty with your system.

Commonly used methods for logging in Node.js are `console.log()` which logs Standard outputs, (stdout) and `console.error()` which will log standard errors (stderr). However, there are more efficient, reliable, popular, and scalable libraries/3rd party APIs that will assist you in logging scripts in your Node.js app.

They include:

#### 1. Winston
[Winston](https://github.com/winstonjs/winston) is a multi-transport async logger, which is simple, universal, and extremely versatile. It makes logging more flexible and extensible. It is the most popular logger based on NPM stats. Winston has different transports with different default levels which indicates message priority. [These levels include](https://github.com/winstonjs/winston#logging-levels)

   - error
   - warn
   - info
   - http
   - verbose
   - debug
   - silly

[**Example of a simple/custom Winston logger**](https://github.com/winstonjs/winston#creating-your-own-logger)

```js
const winston = require("winston");
const logger = winston.createLogger({
  transports: [new winston.transports.Console()],
});
logger.info("Information message");
logger.warn("Warning message");
logger.error("Error message");
```
[**Winston logger with file transport**](https://github.com/winstonjs/winston#multiple-transports-of-the-same-type)

```js
const winston = require("winston");
// Logger configuration
const logConfiguration = {
  transports: [
    new winston.transports.Console({
      level: "verbose",
    }),
    new winston.transports.File({
      level: "error",
      filename: "./logs/example-3.log",
    }),
  ],
};
//Create logging configurations
const logger = winston.createLogger(logConfiguration);
// Log some messages
logger.silly("Trace message, Winston!");
logger.debug("Debug message, Winston!");
logger.verbose("A bit more info, Winston!");
logger.info("Hello, Winston!");
logger.warn("Heads up, Winston!");
logger.error("Danger, Winston!");
```

#### 2. Morgan
[Morgan](https://github.com/expressjs/morgan) is an HTTP request logger middleware for Node.js applications. Morgan gives insights on how your app is being used and alerts you on potential errors and issues that could be threats to your application. Morgan is considered the most reliable HTTP logger by Node.js developers. Morgan is designed to log errors the way servers like [Apache](https://httpd.apache.org/docs/1.3/logs.html) and [Nginx](https://docs.nginx.com/nginx/admin-guide/monitoring/logging/) carry out to the access-log or error-log.

Below we have an example app that will log all requests in the [Apache](https://httpd.apache.org/docs/1.3/logs.html) combined format to one log file per day in the log/ directory using the [rotating-file-stream module](https://www.npmjs.com/package/rotating-file-stream).

```js
var express = require("express");
var morgan = require("morgan");
var path = require("path");
var rfs = require("rotating-file-stream");
var app = express();
// create a rotating write stream
var accessLogStream = rfs.createStream("access.log", {
  interval: "1d", // rotate daily
  path: path.join(__dirname, "log"),
});
// setup the logger
app.use(morgan("combined", { stream: accessLogStream }));
app.get("/", function (req, res) {
  res.send("hello, world!");
});
```

[Code Source](https://www.npmjs.com/package/morgan#log-file-rotation)

#### 3. Bunyan
[Bunyan](https://github.com/trentm/node-bunyan) is a lightweight logger that creates log records as JSON.
```js
var bunyan = require("bunyan");
var log = bunyan.createLogger({ name: "myapp" });
log.info("hi");
log.warn({ lang: "fr" }, "au revoir");
```

Click this link for more details to [get started with Bunyan](https://github.com/trentm/node-bunyan#introduction).

#### Logging best practices
- Logging should be meaningful and have a purpose
- Adopt logging at the early stage of app development
- Divide logs into several log files in case you have an application with huge traffic
- Logging should be structured and done in levels

### Run parallel
Ensure parallel execution flow when requesting remote services, database calls, and file system access. Parallelizing tasks will greatly reduce latency and minimize any blocking operations. Parallel operation means running multiple things at the same time. You should note that parallel is different from asynchronous. With parallel, you do not have control of what finishes before the other, as your code will be optimized to run tasks at the same time. Generally, Node.js does not technically execute these multiple tasks at the same time, what happens it that each task is pushed to an asynchronous event loop with no control of which task will finish before the other. If your execution needs to complete one or more tasks before the other please consider going asynchronous.

For example:

[Async.js](https://caolan.github.io/async/v3/) is used to run parallel functions  `async.parellel(tasks, callback)`.

- **Tasks** : tasks to be executed such as arrays objects etc.
- **Callback** : pass all tasks results and execute when all task compilation is completed

An example of using a dashboard where functions such as `getUserprofile()`, `getrecentActivity()`, `getNotifications()`, can execute parallel using async.js

```js
async.parallel([
	getNotifications,
	getUserprofile,
	getrecentActivity
	],
  function(err ,results){
		if(err){
		 return console.error(err);
		}
		//task results
	});
```

**Simple example using async.parallel**

```js
const async = require('async')
function runInParallel() {

async.parallel(
  [
    (constshort = shortTimeFunction),
    (medium = mediumTimeFunction),
    (long = longTimeFunction),
  ],
  function (err, results) {
    if (err) {
      return console.error(err);
    }
    console.log(results);
  }
);
}
```

OUTPUT
```bash
Result : {short: "resultOfShortTime", medium: "resultOfMediumTime", long: "resultOfLongTime"}.
```

### Client-side rendering
Powerful MVC/[MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel) has contributed to the growth of single-page apps. Frameworks such as [AngularJS](https://angularjs.org/), [Ember](https://emberjs.com/), [Meteor](https://docs.meteor.com/#/full/), and [BackboneJS](https://backbonejs.org/) are examples of current powerful [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) technology for client client-side rendering.

These frameworks return dynamic data as JSON and display them on a webpage UI rendered on the client-side. What this means is that no mark-ups layout will be sent with each request. Plain JSON will be sent and then rendered on the client-side making the page static on page reload. This saves on bandwidth, which translates to a higher-speed and performance.

### Gzip compression
Gzip compresses HTTP requests and responses. [Gzip](https://nginx.org/en/docs/http/ngx_http_gzip_module.html) compresses responses before sending them to the browser, therefore, the browser takes a shorter time to fetch them. Gzip also compresses the request to the remote server, which significantly increases web performance.

When using [ExpressJS](http://expressjs.com/), you can choose to use [compression](https://github.com/expressjs/compression) (a Node.js compression middleware that supports deflate and Gzip and serve static content). Using the [compression](https://github.com/expressjs/compression) library `app.use()` will compress every request that passes through the middleware.

Example

```js
var compression = require("compression");
var express = require("express");
var app = express();
// compress all responses
app.use(compression());
// add all routes
```

Here is more details on how to [connect express with compression](https://github.com/expressjs/compression#examples).

### Avoid memory leaks
A [memory leak](https://en.wikipedia.org/wiki/Memory_leak) occurs when a computer program incorrectly manages memory allocations in a way that memory is no longer needed and is not released. With memory leaks, a loaded page will reserve more and more memory and will slowly occupy your available space to a point where CPU usage is overstretched and is severely affecting your application performance.

You may choose to restart your application and these issues will magically disappear but this will not be a reliable solution as the problem will repeat itself and the memory will pile up periodically. Memory leaks can come from [DOM](/engineering-education/document-object-model/) that has been removed from a page but some variables still make some reference to them, if you happen to remove DOM values make sure to set them to null (when null, the garbage collector will eliminate them) and avoid memory leaks.

Use [Chrome Dev Tools](https://developers.google.com/web/tools/chrome-devtools?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2018Q2) to analyze if your web page has any memory leaks. Chrome dev tool is simple, it will help you to catch, and debug memory leaks with a dedicated DevTool for Node.js. [This article](https://marmelab.com/blog/2018/04/03/how-to-track-and-fix-memory-leak-with-nodejs.html) will help you understand more about how to detect and solve memory leaks using ChromeDevTool.

### Real-time monitoring
Monitoring help get insights into your production application to better ensure a fast, stable, and reliable system. Insights are critical in helping detect performance problems within your system.

As a developer, you need to know when your system is down before your customers start complaining about your faulty system. That is why you need real-time alerts so you can be notified immediately.

Proper monitoring also helps get insight into the features of your application's behavior. You need to know how much time your app takes to run each function in the production environment. Also, if you are using microservices, you need to monitor network connections and lower delays in the communication between the two services. A few commonly used third party tools to monitor Node.js apps includes

- [LogicMonitor](https://www.logicmonitor.com/support/about-logicmonitor/overview/what-is-logicmonitor)
- [Monitis](https://www.monitis.com/)
- [Newrelic](https://newrelic.com/products/application-monitoring)
- [Stackify](https://stackify.com/retrace/)

You may consider using [Google analytics](https://analytics.google.com/analytics/academy/course/6) to get insights such as user visits, traffic, traffic sources, bounce rate, user retention rate, sessions, session durations as well as page views.

Node.js monitoring frameworks include [Hapi](https://github.com/hapijs/hapi), [Restify](http://restify.com/), [Derby](https://derbyjs.com/), [Express](https://expressjs.com/), [Koa](https://koajs.com/), and [Mocha](https://mochajs.org/).

### Keeping your code light and compact
When developing mobile apps, make sure you apply the concept of making your codebase small and compact for both the client code and server code. This will reduce latency and increase speed for load times.

When it comes to making your code light, a single page web app is a great choice to consider. For example, let's assume your web app has a page with six JavaScript files when this page is accessed on the browser, that browser will make six HTTP requests to fetch all your files. This will create a block and wait scenario. This is a good example of when you could minimize and link your multiple files into one to avoid scenarios like this.

Node.js has a lot of open source libraries and modules. During the development stage, you need to ask yourself why are you using this framework over another, you need to find out if a framework is worth using or if there are other simple ways to write your code.

The point is when you consider using a framework it should be well worth it. However, this does not mean choosing frameworks is bad, frameworks are great, they are scalable and have undisputed benefits. Consider using a framework only if it will simplify your code.

When dealing with date objects, it would be advisable to use a library like [Moment](https://momentjs.com/docs/#/use-it/) instead of using the native JavaScript date object. Not because JavaScript date objects are bad in any way, but you will need to add a lot of code setups just to set up and display a simple date format.

For example:

- Using native JavaScript date object

```js
var NowDate = new Date();
var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var sDay = NowDate.getDate();
var sMonth = NowDate.getMonth() + 1;
var sYear = NowDate.getFullYear();
console.log(sYear + '-' + sMonth + '-' + sDay);
```

- Using Moment

```js
var moment = require('moment')
var today = moment();
console.log(today.format('YYYY-M-D'));
```

- [Using date-fns](https://date-fns.org/docs/Getting-Started)

```js
var format = require("date-fns/format");
var today = format(new Date(), "yyyy-M-dd");
console.log(today);
```

As a developer, which of the example methods above would you consider?

Remember all these code blocks outputs today's date. When working with frameworks, consider looking at alternative modules that are relatable to your code context and that may be a better fit.

For example, date-fns is an alternative date object library to moment. Interestingly date-fns is considered more light-weight compared to moment yet they do the same job.

As a developer, you need to understand that dilemma and wisely choose which library to use during the development stage. In such a scenario date-fns will improve your bundle size since it is smaller and help avoid performance overhead.

### Conclusion
Node.js performance optimization is a broad topic with much ground to cover. This article only covered the tip of the iceberg about some of the common practices you can adopt to get higher-performance results.

Other common practices that you should consider include:
- Using the latest stable [Node.js updates](https://nodejs.org/en/)
- CPU profiling
- Node.js timers to schedule tasks
- Prioritize access to local variables.
- Avoid using too much memory
- Eliminate unused components of .js libraries
- Removing unused lines of codes
- Having a well-defined execution context
- [Load balancing](https://docs.nginx.com/nginx/deployment-guides/load-balance-third-party/node-js/#configuring-basic-load-balancing)
- [Memory optimization](https://redis.io/topics/memory-optimization)
- Using Standard V8 GC
- Avoiding global variables

Consider doing some work on your own and find out which segment of your app needs to be optimized. However, as you practice these optimization tips do not forget security practices such as [SSL/TLS AND HTTP/2](https://docs.nginx.com/nginx/technical-specs/#http-2-and-ssl-tls).
