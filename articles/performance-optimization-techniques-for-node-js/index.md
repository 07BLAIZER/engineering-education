Performance is an important aspect when building webpages and applications. When developing applications, you need to understand how long your users interacts with your app, how often they leave as well as the response time. The first 10 seconds are vital to determine if a user leaves or continues interacting with your pages. In addition, you must clearly speed up the value for these 10 seconds and get the user's attention to spend more time on your page. The key rehearsal that you need to practice is to optimize your page and speed up the response time to your users. Your web page performance will determine the users' value to time. The point is speed. And how do you achieve a good speed reputation? Well, optimization is the way to go. Take performance as task completion (work done in a timely manner) and good user experience.

Node.js is known to produce super-fast performing and scalable web applications with an event-driven architecture and non-blocking (asynchronous) tasks that run on a single thread. As a developer, you still need your application to be even faster and optimal. I would say Node.js is fire and performance optimization is gasoline, you can imagine how blazing your app shall be. This article will cover techniques, tools, and tips to optimize Node.js apps and achieve high-performance.

### Asynchronous coding

Node.js is designed with single thread concurrency architectures with non-blocking operations. Asynchronous is heavily used in Node.js to ensure a non-blocking operations flow. Asynchronous I/O permits other processing to continue even before the first transmission has finished. Synchronous coding can potentially lock your web, it uses blocking operations that might block your main thread and this will drastically reduce your web performance. Asynchronous coding will allow you to use queues to monitor your workflow, allowing you to append additional tasks and extra callbacks without blocking your main thread. Even though you may try to use Asynchronous methods, in some instances, it is possible to find your web making some blocking calls. This is commonly possible when using third-party modules, you should keep an eye on the external libraries you are using and take precautions to avoid them to dominate synchronous calls.

Example: file read operation in both models ([using Node.js file system](https://nodejs.dev/learn/the-nodejs-fs-module))

#### Synchronous
```js
var fs = require('fs');
var content = fs.readFileSync("app.js", "utf8");
console.log(content);
console.log('waiting for the file to read.........');
```
![Synchronous](/engineering-education/performance-optimization-techniques-for-node-js/synchronous.png)

#### Asynchronous
```js
//inlude file system module
var fs = require('fs');
//readFile() reads the file
fs.readFile("app.js", "utf8", function (err, content) {
    if (err) {
        return console.log(err);
    }
    //read the file
    console.log(content);
});
console.log('waiting for the file to read.....');
```
![Asynchronous](/engineering-education/performance-optimization-techniques-for-node-js/asynchronous.png)

In the above examples
Synchronously, all processes are paused until the file reading is over. The `readFileSync()` will first read the file and store its data in the memory before printing the data and message in the console. Asynchronous will print the console message as the system perform other tasks. The "waiting for the file to read" is printed before the file content even though it was the last command. A callback function will be called when file reading is done. The asynchronous model will have faster execution of our program and avoid the so-called "Call-back Hell".

### Query optimization

Just imagine having more than one million rows data to query from your database table, the process generated by this database to get the endpoint of this data will greatly affect your application performance, and displaying this data can becomes slower. Using bad queries will further make your application almost useless to satisfy your users. The solution to this is to perform query optimization.

#### Basic Tips to improve your database performance/[optimization overview](https://dev.mysql.com/doc/refman/8.0/en/optimize-overview.html)

- Database and table [indexing](https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html)/structure. Proper indexing will speed up data retrieval between your databases and tables to select and sort rows faster. Proper indexing will help you to avoid columns overlapping.

- Avoid [SELECT](https://dev.mysql.com/doc/refman/8.0/en/select-optimization.html) *

That the most obvious thing you will use to select your columns, right? You should not overlook how cumbersome this query can be, to list down columns you have in a table. Go for a more distinct approach using the SELECT statement to query only the data you need and avoid extra fetching loads on your database.

- Use the [clause WHERE](https://dev.mysql.com/doc/refman/8.0/en/where-optimization.html)

The goal of the query to pull the required records from your database. WHERE clause helps to filter the records and limit the number of records to be pulled based on conditions. WHERE replaces the HAVING clause which selects records before filtering the dataset. In SQL operations, WHERE statements are faster as it reduces that data being processed by the database engine.

- [Use LIMIT](https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html) to sample the query results

LIMIT will return only the specified number of records. When using LIMIT, ensure that the results are desirable and meaningful when a limit is imposed on the dataset.

- Avoid columns [text joins.](https://dev.mysql.com/doc/internals/en/optimizer-joins.html)

Joins with strings/tests are considered much slower compared to numeric columns. The solution to this is to always make sure foreign key strings have an equivalent numeric representation where join can be performed.

Example:
```sql
SELECT from cars
WHERE color = 'red'
```
```sql
SELECT from cars
WHERE color_id = 2
```
The second query will execute faster than the first query
- Running queries during off-peak hours.

In the production database, analytical and database management queries should be executed when the concurrent users are at their lowest peak. Typically at night around 3 to 5 am.

#### Other Tips
- Avoid SELECT DISTRICT
- Statements such [INSERT](https://dev.mysql.com/doc/refman/8.0/en/insert-optimization.html), [UPDATE](https://dev.mysql.com/doc/refman/8.0/en/update-optimization.html) should be well optimized
- Avoid sub-optimal queries as they execute row by row which slows down your engine
- [Table optimazition](https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html)
- [Sub querry optimation](https://dev.mysql.com/doc/refman/8.0/en/optimizing-subqueries.html)
- Use wildcard (%) character appropriately
- Avoid over normalization and use numeric for primary keys
- Avoid looping statements looping queries will slow your sequence

### Caching

A cache is a memory buffer where frequently accessed data is temporarily stored (that will not be changed in the near future) in order to be accessed more quickly. Cached data is then retrieved without having to access the original data. Caching will improve your app response time and even reduce some costings such as bandwidth and data volumes.

Catching is a great practice to improve your app performance. It you have fewer users, your app performance may not be greatly affected. However, performance problems may arise when the traffic grows and you need to maintain the load balance. When this happens, caching your app regularly will be a great hit to achieve high-performance. Caching can be a little bit hard thus you need tools to assist you to cache your app efficiently such as

- [Redis cache](https://redis.io/topics/client-side-caching) it is entirely asynchronous with optimal performances to handle cached data requests in a single thread. Consider checking it out, it is a smooth API that will help you do and manage your client-side and server-side cache.
- [Memcached](https://memcached.org/) stores data across different nodes with hashing schema that provides hash table functionality in a way that adding or removing a server node does not significantly change the [mapping of the keys to server nodes](https://npm.runkit.com/memcached).
- [Node-cache](https://www.npmjs.com/package/node-cache) works almost like Memcached with the set, get, and delete methods. It has a timeout that deletes data from the cache when the time out expires.
- [Nginx](https://docs.nginx.com/nginx/deployment-guides/load-balance-third-party/node-js/#configuring-content-caching) will help to maintain load balance. Nginx will help to cache static files, which will drastically offload the work of the application server. It offers low memory usage and high concurrency.

### Go session free

Session data are stored in memory. As traffic in your app grows, more sessions will be generated and this might add significant overhead to your server. You need to find a means to store session data or minimize the amount of data stored in the session. Modules such as [Express.js](https://expressjs.com/) can help you create server protocols which are stateless. Stateless protocols do not save or store any information from previous visits.

Switch to an external session store such as [Redis](https://redis.io/documentation) , [Nginx](https://docs.nginx.com/nginx/deployment-guides/load-balance-third-party/node-js/#configuring-basic-session-persistence), [MongoDB](https://docs.mongodb.com/manual/reference/method/Session/). Where possible, the best option is to store no session state in your server-side and you will get better performance.

### Script tracing and logging

Logging helps to track your application activities and traffic. When an app is running there might be possibilities to get fatal errors(even though your app is running properly after production testing), and you need to get this on time, find what code has an error, and fix them even before your user notice that something is faulty in your system.

The commonly used method for logging in Node.js are `console.log()` logs Standard outputs (stdout) and `console.error()` will log standard errors (stderr). However, there are more efficient, reliable, popular, and scalable libraries/3rd party APIs that will assist you to log scripts in your Node.js app.

They include:

#### 1. Winston
[Winston](https://github.com/winstonjs/winston) is a multi-transport async logger, which is simple, universal, and extremely versatile. It makes logging more flexible and extensible. It is the most popular logger based on NPM stats. Winston has different transports with different default levels which indicates message priority. [This level includes](https://github.com/winstonjs/winston#logging-levels)

   - error
   - warn
   - info
   - http
   - verbose
   - debug
   - silly

[**Example simple/custom wiston logger**](https://github.com/winstonjs/winston#creating-your-own-logger)
```js
const winston = require("winston");
const logger = winston.createLogger({
  transports: [new winston.transports.Console()],
});
logger.info("Information message");
logger.warn("Warning message");
logger.error("Error message");
```
[**Winston logger with file transport**](https://github.com/winstonjs/winston#multiple-transports-of-the-same-type)
```js
const winston = require("winston");
// Logger configuration
const logConfiguration = {
  transports: [
    new winston.transports.Console({
      level: "verbose",
    }),
    new winston.transports.File({
      level: "error",
      filename: "./logs/example-3.log",
    }),
  ],
};
//Create logging configurations
const logger = winston.createLogger(logConfiguration);
// Log some messages
logger.silly("Trace message, Winston!");
logger.debug("Debug message, Winston!");
logger.verbose("A bit more info, Winston!");
logger.info("Hello, Winston!");
logger.warn("Heads up, Winston!");
logger.error("Danger, Winston!");
```
#### 2. Morgan

[Morgan](https://github.com/expressjs/morgan) is an HTTP request logger middleware for Node.js applications. Morgan gives insights on how your app is being used and alerts you on potential errors and issues that could be threats to your application. Morgan is considered the most reliable HTTP logger by Node.js developers. Morgan is designed to log errors the way servers like [Apache](https://httpd.apache.org/docs/1.3/logs.html) and [Nginx](https://docs.nginx.com/nginx/admin-guide/monitoring/logging/) do to the access-log or error-log.

Sample app that will log all requests in the [Apache](https://httpd.apache.org/docs/1.3/logs.html) combined format to one log file per day in the log/ directory using the [rotating-file-stream module](https://www.npmjs.com/package/rotating-file-stream).
```js
var express = require("express");
var morgan = require("morgan");
var path = require("path");
var rfs = require("rotating-file-stream");
var app = express();
// create a rotating write stream
var accessLogStream = rfs.createStream("access.log", {
  interval: "1d", // rotate daily
  path: path.join(__dirname, "log"),
});
// setup the logger
app.use(morgan("combined", { stream: accessLogStream }));
app.get("/", function (req, res) {
  res.send("hello, world!");
});
```
[Code Source](https://www.npmjs.com/package/morgan#log-file-rotation)

#### 3. Bunyan
[Bunyan](https://github.com/trentm/node-bunyan) is a lightweight logger that creates log records as JSON.
```js
var bunyan = require("bunyan");
var log = bunyan.createLogger({ name: "myapp" });
log.info("hi");
log.warn({ lang: "fr" }, "au revoir");
```
Check more to [get started with Bunyan](https://github.com/trentm/node-bunyan#introduction)

#### Logging best practices

- Logging should be meaningful
- Adopt logging at the early stage of app development
- Divide logs into several log files in case you have an application with huge traffic
- Logging should be structured and done in levels

### Run parallel

Ensure parallel execution flow when requesting remote services, database calls, and file system access. Parallelizing tasks will greatly reduce latency and minimize blocking operations. Parallel operation means running multiple things at the same time. You should note that parallel is different from asynchronous. With parallel, you do not have control of what finishes before the other, as your code will be optimized to run tasks at the same time. Generally, Node.js does not technically execute these multiple tasks at the same time, what happens it that each task is pushed to an asynchronous event loop with no control of which task will finish before the other. If your execution needs to complete one or more tasks before the other please consider going asynchronous. 

For example

[Async.js](https://caolan.github.io/async/v3/) is used to run functions parallel `async.parellel(tasks, callback)`.

- **Tasks** : tasks to be executed such as arrays objects etc.
- **Callback** : pass all tasks results and execute when all task compilation is completed

An example of user a dashboard where functions such as `getUserprofile()`, `getrecentActivity()`, `getNotifications()`, can be execute parallel using async.js
```js
async.parallel([
	getNotifications,
	getUserprofile,
	getrecentActivity
	],
  function(err ,results){
		if(err){
		 return console.error(err);
		}
		//task results
	});
```
**Simple example using async.parallel**
```js
const async = require('async')
function runInParallel() {

async.parallel(
  [
    (constshort = shortTimeFunction),
    (medium = mediumTimeFunction),
    (long = longTimeFunction),
  ],
  function (err, results) {
    if (err) {
      return console.error(err);
    }
    console.log(results);
  }
);
}
```
OUTPUT
```
Result : {short: "resultOfShortTime", medium: "resultOfMediumTime", long: "resultOfLongTime"}. 
```
### Client-side rendering

Powerful MVC/[MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel) has contributed to the growth of single-page apps. Frameworks such as [AngularJS](https://angularjs.org/), [Ember](https://emberjs.com/), [meteor](https://docs.meteor.com/#/full/), and [BackboneJS](https://backbonejs.org/) are examples of current powerful [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) technology for client client-side rendering. These frameworks return dynamic data as JSON and display them on webpage UI rendered on the client-side. What this means is that no mark-ups layout will be sent with each request. Plain JSON will be sent and then rendered on the client-side making the page static on page reload. This saves on bandwidth, which translates to high-speed performance.

### Gzip compression

Gzip compresses HTTP requests and responses. [Gzip](https://nginx.org/en/docs/http/ngx_http_gzip_module.html) compresses response before sending them to the browser hence, the browser takes a short time to fetch them. Gzip also compresses the request to the remote server, which significantly increases web performance.

When using [ExpressJS](http://expressjs.com/), you can choose to use [compression](https://github.com/expressjs/compression) (a Node.js compression middleware that supports deflate and Gzip and serve static content). Using compression library `app.use()` will compression every request that passes [through the middleware will be compressed](https://github.com/expressjs/compression).

Example
```js
var compression = require("compression");
var express = require("express");
var app = express();
// compress all responses
app.use(compression());
// add all routes
```
Check more on how to [connect express with compression](https://github.com/expressjs/compression#examples).

### Avoid memory leaks

A memory leak occurs when a computer program incorrectly manages memory allocations in a way that memory which is no longer needed is not released ([Wikipedia](https://en.wikipedia.org/wiki/Memory_leak)). With memory leaks, a loaded page will reserve more and more memory and will slowly occupy your available space to a point where CPU usage is overstretched and severely affecting your application performance. You may choose to restart your application and these issues will magically vanish but this will not be a reliable solution as the problem will repeat itself and the memory will pile up periodically. Memory leaks can come from DOM that has been removed from a page but some variables still make some reference to them, If you happen to remove DOM values make sure to set them to null (when null, the garbage collector will eliminate them) to avoid memory leaks.

Use [Chrome Dev Tools](https://developers.google.com/web/tools/chrome-devtools?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2018Q2) to analyze if your web has any memory leaks. Chrome dev tool is simple, it will help you to catch, and debug memory leaks with Open dedicate DevTool for Node.js. [This article](https://marmelab.com/blog/2018/04/03/how-to-track-and-fix-memory-leak-with-nodejs.html) will help you understand more on how to detect and solve memory leaks using CromeDevTool.

### Real-time monitoring

Monitoring helps to get insights of your production application to ensure a fast, stable, and reliable system. Insights are critical in helping to detect performance problems within your system. As a developer, you need to know when your system is down even before your customers start to complain about how your system is faulty. Thus, you need real-time alerting so you can be notified immediately.

Proper monitoring also helps get insight into features of your application's behaviour. You need to know how much time does your app takes to run each function in the production environment. Also, if you are using microservices, you need to monitor network connections and lower delays in the communication between two services. The commonly used third party tool to monitor Node.js apps includes
- [LogicMonitor](https://www.logicmonitor.com/support/about-logicmonitor/overview/what-is-logicmonitor)
- [Monitis](https://www.monitis.com/)
- [Newrelic](https://newrelic.com/products/application-monitoring)
- [Stackify](https://stackify.com/retrace/)

You may consider using [Google analytics](https://analytics.google.com/analytics/academy/course/6) to get insights such as user visits, traffic, and traffic sources, bounce rate, user retention rate, sessions, and session durations as well as page views.

Node.js monitoring frameworks include [Hapi](https://github.com/hapijs/hapi), [Restify](http://restify.com/), [Derby](https://derbyjs.com/), [Express](https://expressjs.com/), [Koa](https://koajs.com/) and [Mocha](https://mochajs.org/).

### Keeping your code small and light and compact

When developing mobile apps apply the ideas of making your codebase small and compact for both client code and serve code. This will reduce latency and increase speed load time. When it comes to making your code light, single page web app is a great consideration. For Example, assume your web has a page with six JavaScript files when this page is accessed on the browser it means a browser will make six HTTP requests to fetch all your files. This will create a block and wait scenario. You then need to minify and concatenate your multiple files into one to avoid scenarios like this.

Node.js has a lot of open source libraries and modules. During the development stage, you need to ask yourself why use this framework and not the other, you need to find out if a framework is worth using or if there are other simple ways to write your code. The point is, when you consider using a framework it should be worth. However, this does not mean choosing frameworks is bad, Frameworks are great, and they are scalable and have undisputed benefits. Consider using a framework if it only simply your code.

For example

When dealing with date objects, it would be advisable to use a library like Moment instead of using native JavaScript date object. Not that JavaScript date objects are bad in any way, only that you need to add a lot of code setups just to set up and display a simple date format.

Example

- Using native JavaScript date object
```js
var NowDate = new Date();
var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var sDay = NowDate.getDate();
var sMonth = NowDate.getMonth() + 1;
var sYear = NowDate.getFullYear();
console.log(sYear + '-' + sMonth + '-' + sDay);
```
- [Using Moment](https://momentjs.com/docs/#/use-it/)
```js
var moment = require('moment')
var today = moment();
console.log(today.format('YYYY-M-D'));
```
- [Using date-fns](https://date-fns.org/docs/Getting-Started)
```js
var format = require("date-fns/format");
var today = format(new Date(), "yyyy-M-dd");
console.log(today);
```
As a developer, which of the above methods would you consider? Remember all these code blocks outputs today's date. When working with frameworks, consider looking at alternative modules that are relatable to your code context.

For example, date-fns is an alternative date object library to moment. Interestingly date-fns is considered more light compared to moment yet they do the same job. As a developer, you need to break that dilemma and choose which library to use more wisely during the development stage. In such a scenario date-fns will improve your buddle size since it is small thus avoiding performance overheads.

### Conclusion

Node.js performance optimization is a huge topic with so many grounds. This article is a tip of an iceberg of some of the common practices you can adopt to get high-performance performance results.

Other topics practices that you should consider includes
- Using the latest stable [Node.js updates](https://nodejs.org/en/)
- CPU profiling
- Node.js timers to schedule tasks
- Prioritize access to local variables.
- Avoid using too much memory
- Eliminate unused components of .js libraries
- Removing unused lines of codes
- Having a well-defined execution context
- [Load balancing](https://docs.nginx.com/nginx/deployment-guides/load-balance-third-party/node-js/#configuring-basic-load-balancing)
- [Memory optimization](https://redis.io/topics/memory-optimization)
- Using Standard V8 GC
- Avoiding global variables

Consider doing some homework and find out which segment of your app needs optimization attention. However, as you practice these optimization tips do not forget security practices such as [SSL/TLS AND HTTP/2](https://docs.nginx.com/nginx/technical-specs/#http-2-and-ssl-tls).