### Introduction
In this tutorial, we will create a React Todo Progressive Web App. A progressive web app refers to an enhanced web application having the same capabilities as a native platform-specific application by utilizing the emerging browser APIs. They are intended to be fast, reliable, and engaging.

### Prerequisites
1. Knowledge of the [JavaScript programming language](https://www.w3schools.com/js/DEFAULT.asp).
2. Basics of React library.Check documentation [here](https://www.reactjs.org).
3. A basic knowledge of [NPM](https://www.npmjs.com/).
4. A code editor, I will be using [VS Code](https://code.visualstudio.com/download)


### Getting started
First, you should have Node.js installed on your computer. You can download the latest version [here](https://www.nodejs.org). The installed version of Node.js runtime comes pre-installed with a node.js package manager(npm).

To confirm that Node.js has been installed, open the terminal and execute the below command:
```bash
    node --version
```
This shows the version of Node.js running on your system and that Node.js has been installed.

Execute the command below to verify if npm is set up and ready for use.
```bash
    npm --version
```
First, we now need to create a new React application using the boilerplate code generated by the
create-react-app command-line utility. On your terminal, execute the following command:
```bash
    npx create-react-app react-pwa
```
This will create a folder named react-pwa. You can now open the project in your favorite code editor.
The folder structure will initially look similar to this:

```bash
node_modules/
public/
|--- favicon.ico
|--- index.html
|--- logo192.png
|--- manifest.json
|--- robots.txt
src/
|--- App.js
|--- App.css
|--- App.test.js
|--- index.js
|--- index.css
|--- serviceWorker.js
|--- logo.svg
.gitignore
package.json
README.md
yarn.lock
```
Our React code will be in the `src` folder. Inside this folder, 
go ahead and delete the `logo. svg` and remove everything in both `App.css` and `App.js` files.


### Creating UI components
Using React means that we will have to break our application into components that represent the 
logical parts of the UI.
We shall have four functional components.
1. App component
2. Form component
3. Todo component
4. TodoList component

### Form component
This is the component that will be used to add new todos.
In your `src/` folder, create a new folder named `components`. Inside the `components` folder, you need to create a file named `Form.js`. 
This is the code for the *Form.js*:

```javascript
import React,{useState} from 'react';
import {v4 as uuidv4} from 'uuid';

const Form =({addTodo})=>{
    
    const [inputText,setInputText]=useState("");

    const inputTextHandler=(e)=>{
        setInputText(e.target.value);
    }
    const submitTodoHandler=(e)=>{
        e.preventDefault();
        if(!inputText){
            return
        }
        addTodo({text:inputText,completed:false,id:uuidv4()});
        setInputText("");
    }

    return(
        <form onSubmit={submitTodoHandler}>
            <input type="text" value={inputText} placeholder="Add Todo" onChange={inputTextHandler}/>
            <button type="submit" className="add-btn">
                Add
            </button>
        </form>
    );
};

export default Form;
```

The code above uses functional components alongside React hooks. Hooks are functions that let you have state and other lifecycle patterns from function components.
We are using the `useState` hook to return two values in an array. The first value is the state, and the second value is the function to update the state. We have named the destructured values as `inputText` and `setInputText`.
Inside the form, we are binding the input tag to an event. When the state of the form changes, The method `inputTextHandler` is invoked and updates the state to the current input value by calling the `setInputText` function.
The form is a controlled component that will track the `inputText`. The `submitTodoHandler` is bound on the form when a button is clicked that will invoke the `addTodo` function. The `addTodo` was passed down as props from the `App` component. The `setInputText` inside the `submitTodoHandler` will simply reset the form.
We now need to add this component in our parent `App` component and pass the function `addTodo`.
Below is the `App.js` file.
```javascript
import React,{useState} from 'react';

import Form from './components/Form';

const App=()=>{

  const addTodo= todo=>{
          const newTodos=[todo,...todos];
           setTodos(newTodos);
       }
  
  return (
    <div>
      <h1>TODO PWA</h1>
      <Form addTodo={addTodo}/>
    </div>
  );
}

export default App;
```

### Creating the TodoList and Todo Components
You need to create a new file named `TodosList.js` inside the components folder.
This is the component that acts as a container to the list of the todo items.
The state is held in the App component and passed to the TodoList as props.
Before creating the TodoList component, the App component has its state, so below is the entire code for the `App.js` file:
A Todo component will represent a single todo item for each row
with buttons to mark it as completed and delete it. The TodoList will be the container for the list of todos available.
Since our Todo component is a child of the TodoList component, We will first create the TodoList component.
First, we need to add the todos state inside the `App.js` file. So we will add extra props to the Form component.
The todos state is [lifted](https://reactjs.org/docs/lifting-state-up.html) in the App component so that our `TodoList` will receive it via the props pattern.
The `App.js` file is now as follows:

```javascript
import React,{useState} from 'react';

import Form from './components/Form';
import TodoList from './components/TodoList';

const App=()=>{

  const [todos,setTodos]=useState([]);

  const addTodo= todo=>{
          const newTodos=[todo,...todos];
           setTodos(newTodos);
       }
  
  return (
    <div>
      <h1>TODO PWA</h1>
      <Form addTodo={addTodo}/>
      <TodoList todos={todos} setTodos={setTodos}/>
    </div>
  );
}

export default App;
```

The todo will be an object with a structure like:
```javascript
    {
      id:v4(),
      task,
      complete:false
    }
```    
The id is a unique identifier or key for a specific todo task. I am using the `uuid` library to generate a unique id.
You can install the `uuid` library by executing the following command in your terminal:
```bash
npm install uuid
```
### The TodoList Component
The `TodoList` is receiving `todos` with an array of objects as the todos and while `setTodos` will be used to update the todos.
We are destructuring to grab all props in the `TodoList` component. We now need to create this `TodoList`.

Go into your components folder and create a new file named `TodoList.js`.
This `TodoList` component code is below:
```javascript
import React from "react";
import Todo from "./Todo";

const TodoList = ({ todos, setTodos }) => {
  const completeTodo = (id) => {
      let updatedTodos=todos.map(todo=>{
          if(todo.id===id){
              todo.completed=!todo.completed;
          }
          return todo;
      })
      setTodos(updatedTodos);
  };
  const removeTodo=(id)=>{
    setTodos(todos.filter(todo=>todo.id!==id));
  }

  return (
    <div className="todo-container">
      <ul className="todo-list">
        {todos.map((todo) => (
          <Todo key={todo.id}
            todo={todo}
            completeTodo={completeTodo} 
            removeTodo={removeTodo}/>
        ))}
      </ul>
    </div>
  );
};

export default TodoList;
```

We are mapping through the todos and returning a new Todo component as the todo item.
The `removeTodo` passes an `id` that uniquely identifies the `todo` in our list. Whatever todo that does not match the provided `id` is filtered and stored in the state using `setTodos`.
We will use the `completeTodo` method to toggle the completed property state and apply a strike-through styling if the component is marked as complete. 
Let us now create the `Todo` component.

### The Todo component
You need to add a new file and name it `Todo.js` in the components folder.
We created the functions that perform the complete and delete operations in our `TodoList` component. We now need to destructure
the props and bind them to the *Check* button for completed tasks and *Delete* buttons.
Clicking the *Check* button will invoke the `HandleComplete` that will call the function `completeTodo` passing the `id`.
The `HandleDelete` method will call the function `removeTodo` and filter out the todo by its `id`.
Check the code below:

```javascript
import React from 'react';

const Todo=({todo,completeTodo,removeTodo})=>{
    
    const HandleComplete=()=>{
        completeTodo(todo.id);
    }
    const HandleDelete=()=>{
        removeTodo(todo.id);
    }

    return(
        <div>
            <div className="todo">
            <li className={todo.completed?"checked":""}>
                {todo.text}
            </li>
            <button onClick={HandleComplete} className="check-btn">{todo.completed?"Uncheck":"Check"}</button>
            <button className="delete-btn" onClick={HandleDelete}>Delete</button>
            </div>
        </div>
    );
}

export default Todo;
```

### Styling
This tutorial assumes you know basics of CSS styling, so I have some basic styles here: 
```css
body{
    background-color: rgb(72, 72, 247);
    font-size: 1.2rem;
    max-width: 100vw;
    max-height: 100vh;
}

input{
    padding:1.3rem 5rem;
    border:none;
    font-size: 1.1rem;
}
.add-btn{
    padding: 1.3rem;
    font-size: 1.1rem;
}

button{
    border:none;
    margin-right: 5px;

}

button:hover{
    transform: scale(0.98);
    transition: linear 0.8s;
    cursor: pointer;
}
.checked{
    color:rgb(240, 240, 247);
    text-decoration: line-through;
}
.todo{
    display: flex;
}

.check-btn{
    color:rgb(14, 14, 14);
    background-color: rgb(95, 130, 245);
}
.delete-btn{
    color: rgb(247, 238, 242);
    background-color: rgb(255, 38, 38);
}
```


### The App so far
Your app so far should look like this:

![React-PWA-image](/engineering-education/react-pwa/react-pwa1.png)
![React-PWA-image2](/engineering-education/react-pwa/react-pwa2.png)


### Adding functionality to make it a PWA
In this part, we will now convert our application into a progressive
web App.
Our application will add functionalities such as running the application offline, caching assets by registering
service workers, and also installing it on the user's device screen.


### Register service worker
A service worker is a script that runs in the background of the browser. 
It is responsible for network intercepts from requests as well as managing caching for offline availability.
This is where we need to focus on that `public` folder.
Inside our `public` folder, open the index.html file. 
Below the file, add the following code. The code below will be inside a script tag.

```javascript
      if("serviceWorker" in navigator){
        window.addEventListener("load",()=>{
          navigator.serviceWorker.register('./serviceworker.js')
          .then(registration=>console.log('Success',registration.scope))
          .catch(err=>console.log("Error",err))
        })
      }
```
In the above code, we are checking if our browser supports service workers.
If this returns true, we will go ahead and register a service worker that points to the file named `serviceWorker.js`. 
Now our service worker is registered in the background. To create the worker, go ahead and create the file `serviceworker.js` inside your `public` directory.
The `serviceworker.js` file will have the following code.

```javascript
const CACHE_NAME="version-1"
const urlsToCache=[" index.html","offline.html"]

const self=this;
// istall sw
self.addEventListener("install",(e)=>{
    e.waitUntil(
        caches.open(CACHE_NAME)
        .then((cache)=>{
            console.log("Opened cache...")
            return cache.addAll(urlsToCache)
        })
    )
})
// listen req
self.addEventListener("fetch",(e)=>{
        e.respondWith(
            caches.match(e.request)
                    .then(()=>{
                        return fetch(e.request)
                                .catch(()=>caches.match('offline.html'))
                    })
        )
})
// activate sw
self.addEventListener("activate",(e)=>{
    const cacheWhitelist=[]
    cacheWhitelist.push(CACHE_NAME);

    e.waitUntil(
        caches.keys().then((cacheNames)=>Promise.all(
            cacheNames.map((cacheName)=>{
                if(!cacheWhitelist.includes(cacheName)){
                    return caches.delete(cacheName)
                }
            })
        ))
    )
})
```
We are starting with the install step. At this step, we are trying to cache some static assets that will be available
offline. This returns a promise to install the service worker when all assets are cached.
The activate listener is where we manage our old caches. 
The `CACHE_NAME` variable will help us fetch resources from the cache.
The above code will now cache and fetch the URL from our cache if we are offline. The offline.html file is used as the fallback markup file when there is no cache.
We defined three events: The fetch event is used in the installation of the service worker.
Our second event will be listening for a network request. The third event is used to activate the service worker.
The self references this keyword of the global service worker itself. Check the code above.

### The Public folder
The public folder currently has this structure:
```bash
    favicon.ico
    index.html
    logo192.png
    logo512.png
    manifest.json
    robots.txt
```
The `favicon.ico`, `logo192.png`, and `logo512.png` are icons that the user sees on the tab of mobile
or desktop devices. The browser will select by size depending on the device.
I will use these default icons in this project.

### Editing index.html file and Manifest
Manifest is a JSON file that has metadata to describe how the app will appear to the user.
We then link it to the HTML in line 18 of `index.html`:
```HTML
<link rel="manifest" href="./manifest.json" />
```
In our `manifest.json` file, the code contains icons used as images of different sizes
on the home screen. The name, theme color, and the start URL, will be in this file.
```JSON
{
  "short_name": "React PWA",
  "name": "A React Todo PWA",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#F4BD42",
  "background_color": "#2B2929",
  "scope":"/"
}

```

We need to edit the `index.html` file to have these changes in our manifest file.
Note there is nothing much is in our body tag in the HTML file as our app was built with React and injected with JavaScript.
The `index.html` file now looks like:
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Todo Web App on PWA"
    />
    <link rel="apple-touch-icon" href="./logo192.png" />
    <link rel="manifest" href="./manifest.json" />
    <title>React Todo PWA</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
        <script>
      if("serviceWorker" in navigator){
        window.addEventListener("load",()=>{
          navigator.serviceWorker.register('./serviceworker.js')
          .then(registration=>console.log('Success',registration.scope))
          .catch(err=>console.log("Error",err))
        })
      }
    </script>
  </body>
</html>
```
I have pointed to use the apple-touch icon to the `logo192.png` and made our icon the `favicon.ico`.
We will now add this in the `manifest.json`.

### Performance of the App
I have used lighthouse to generate an audit report:
Our App scores 89/100 on performance.
Note that this will not pass the HTTPS audit in the development environment. So if hosting is needed, make sure the production web-server supports HTTPS.
Here is the final version of the App:


![PWA Performance](/engineering-education/react-pwa/performance.png)
![PWA install](/engineering-education/react-pwa/install.png)
![Requirements for PWA](/engineering-education/react-pwa/requirements.png)

Our app is now installable by clicking the plus icon on chrome.
The cache will make it available for offline use.

You can interact with the deployed app on [netlify](https://infallible-brahmagupta-cdcafd.netlify.app/)

### Summary
In summary, we learned how to create a Todo app using the React library, with awesome features such as React Hooks and functional components. We created a Form input and functionality to add todo tasks, mark them as complete and delete the todo tasks. We then explored some introduction to Progressive Web Apps and turned our Todo app into a PWA.