### Introduction
In this tutorial, we are going to create a new React Todo application and turn it into a 
progressive web app (PWA). You will be able to add a todo, mark it as complete and delete
the todo item. We will use the React library for the application and workbox for making it a PWA.

### Prerequisites
1. Knowledge of the [JavaScript programming language](https://www.w3schools.com/js/DEFAULT.asp).
2. Basics of React library.Check documentation [here](https://www.reactjs.org).
3. A basic knowlegde of [NPM](https://www.npmjs.com/).
4. A code editor, I will be using [VS Code](https://code.visualstudio.com/download)


### Getting started
First, you will need to have Node installed on your computer. You can download the latest version [here](https://www.nodejs.org). The installed version of Node runtime comes pre-installed with a node package manager(npm).

To confirm that Node has been installed, open the terminal and execute the below command:
```bash
    node --version
```
This shows the version of Node running on your system confirming that Node has been installed.
<br>
Execute the command below to verify if npm is setup and ready for use.
```bash
    npm --version
```
First, we now need to create a new React application using the boilerplate code generated by the
create-react-app commandline utility. On your terminal, execute the following command:
```bash
    npx create-react-app react-pwa
```
This will create a folder named react-pwa. You can now open the project in your favourite code editor.
The folder structure will initially look similar to this:

```bash
node_modules/
public/
|--- favicon.ico
|--- index.html
|--- logo192.png
|--- manifest.json
|--- robots.txt
src/
|--- App.js
|--- App.css
|--- App.test.js
|--- index.js
|--- index.css
|--- serviceWorker.js
|--- logo.svg
.gitignore
package.json
README.md
yarn.lock
```
We can assume the `public/` directory for now and focus on the `src` folder where we will write most of our React code.
The `package.json` file contains the package dependencies and some script configuration of the project.
Go ahead and delete the `logo.svg` and remove everything in both `App.css` and `App.js` files.


### Creating UI components
Using React means that we will have to break our application into components that represent the 
logical parts of the UI.
We shall have four functional components.
1. App component
2. Form component
3. Todo component
4. TodoList component

### Form component
This is the component that will be used to add new todos.
A user should be able to type in the form and have the state updated. The state will leave in the `App.js` file and passed to other components where it is needed. So I will first show you the code for our `App.js` and the state the Form component
is taking as props before we create the Form component.
```javaScript
import React,{useState} from 'react';

import Form from './components/Form';

const App=()=>{

  const [inputText,setInputText]=useState("");
  
  return (
    <div>
      <h1>TODO PWA</h1>
      <Form setInputText={setInputText} inputText={inputText}/>
    </div>
  );
}

export default App;
```
This is the main App component. We are using functional components alongside React hooks. Hooks are functions that let you have state and other lifecycle patterns from function components. In this case, the `useState()` hook will
be used for the state. The `useState` hook returns two values in an array. The first is the state, and the second value being the function to update it when the state changes.
The second line of our code imports the Form component, which we will be creating in a moment. The Form component is mounted to the UI on the App component and the initial props attributes are passed down to the child component, in this case, our Form component. Now we will go ahead and create the Form component and utilize props from the App component.
In your `src/` folder, create a new folder named `components`. Inside the `components` folder, you need to create a file named `Form.js`. This is the component that one will type in an item and later have it show on the to-do list.
<br>

```javaScript
import React from 'react';

const Form =({inputText,setInputText})=>{
    
const inputTextHandler=(e)=>{
    setInputText(e.target.value)
}

    return(
        <form>
            <input type="text" value={inputText} placeholder="Add Todo" onChange={inputTextHandler}/>
            <button type="submit">
                Add
            </button>
        </form>
    );
};

export default Form;
```
So let us go through this, inside the form, we are binding the input tag to an event. On change of form state, The method `inputTextHandler` is invoked. Inside the method, we call the setInputText function that updates the inputText to the current state value.

### Creating a Todo
First, we need to add a new state inside the `App.js` file. This is the state set once the Add button is clicked. Note that this is the value that inputText current has. So we will add extra props to the Form component. Clicking the Add button will create the new to-do task and we store this in the todos array to be later used on the UI.
Our code in the `App.js` file will now look like this:
```javascript
import React,{useState} from 'react';

import Form from './components/Form';

const App=()=>{

  const [inputText,setInputText]=useState("");
  const [todos,setTodos]=useState([]);
  
  return (
    <div>
      <h1>TODO PWA</h1>
      <Form setInputText={setInputText} inputText={inputText} todos={todos} setTodos={setTodos} />
    </div>
  );
}

export default App;
```

The form can now be used to add new todos to the list. It is a **controlled** component,
as the data is managed by React rather than the DOM.
The to-do will be an object with structure like:
```javascript
    {
      id:v4(),
      task,
      complete:false
    }
```    
The id is a unique identifier or key for a specific to-do task. I am using `uuid` libary to generate a unique id.
You can install the `uuid` library by executing the following command:
```bash
npm install uuid
```
Our Form component has extra props passed to it, the todos and the setTodos that updates our todos array.
Using destructuring we grab all props in the Form component.
The submitTodoHandler method is binded to the Add button and invoked when a button is clicked to create the todo.
This adds a new todo item by first copying initial todos if any exists using ES 2015 spread syntax.
Now our Todo is created and the setInputText is called to simply reset the form.

This will be the code below:
```javascript
import React from 'react';
import {v4 as uuidv4} from 'uuid'

const Form =({setInputText,todos,setTodos,inputText})=>{
    
const inputTextHandler=(e)=>{
    setInputText(e.target.value)
}
const submitTodoHandler=(e)=>{
    e.preventDefault() // supress the default form behaviour
    //create a new todoHandler
    setTodos([
        ...todos,{text:inputText,completed:false,id:uuidv4()}
    ])
    setInputText("") // clears the input form once the button is clicked
}
    return(
        <form>
            <input type="text" value={inputText} placeholder="Add Todo" onChange={inputTextHandler}/>
            <button type="submit" onClick={submitTodoHandler}>
                Add
            </button>
        </form>
    );
};

export default Form;
```

### Creating the Todo and TodoList
A Todo component will be a card that holds the todo for each row. On the left will be the text and the right side of it will be the button to mark it as completed or delete. It will represent a single item on the row.
The TodoList is the container for the list of todos available.

Since our Todo component is a child of the TodoList component, We will first create the TodoList component.

### TodoList component
You need to create a new file named `TodosList.js` inside the components folder.
This is the component that will have a list of to-do items.
The state is held in the App component and passed to the TodoList as props.
Before creating the TodoList component, the App component has its state, so below is the entire code for the `App.js` file:
_App.js_
```javascript
import React,{useState} from 'react';
import './App.css';

import Form from './components/Form';
import TodoList from './components/TodoList';

const App=()=>{

  const [inputText,setInputText]=useState("");
  const [todos,setTodos]=useState([]);
  
  return (
    <div>
      <h1>TODO PWA</h1>
      <Form setInputText={setInputText} inputText={inputText} todos={todos} setTodos={setTodos} />
      <TodoList todos={todos} setTodos={setTodos}/>
    </div>
  );
}

export default App;
```

### Our TodoList
Inside your components folder, create a new file named `TodoList.js`.
This component simply receives todos object in an array, we then map through them and return a new Todo item.
```javascript
import React from 'react';
import Todo from './Todo'

const TodoList=({todos,setTodos})=>{
    return(
        <div className="todo-container">
            <ul className="todo-list">
                {todos.map((todo)=>(
                    <Todo text={todo.text} completed={todo.completed} key={todo.id} todos={todos} todo={todo} setTodos={setTodos} />
                ))}
            </ul>
        </div>
    );
}

export default TodoList;
```
### The Todo
The component receives the destructured todos. On the left of the todo is the item and on the right are the buttons
to delete and mark the item as completed. deleteHandler is the method bound to the delete button to delete a single
todo by its id. With ES 2015 higher-order array methods, the filter method is applied to well, filter out the item out of the array that does not equal the id i.e the item that matches the id is will not go through the new returned array.
Note the new returned array is our updated todos from the setTodos function.
The completeHandler method in the Check button toggles the completed property and applies a strike-through if the component is marked as completed. It will check if the completed property is true and change its class property to
style it accordingly.
The Todo returns a `div` containing the todo item and the buttons.
_Todos.js_
```javascript
import React from 'react';

const Todo=({text,completed,todos,todo,setTodos})=>{
    const deleteHandler=()=>{
        setTodos(todos.filter(item=>item.id!==todo.id))
    }
    const completeHandler=()=>{
        setTodos(todos.map(el=>{
            if(element.id==todo.id){


                return{
                    ...element, completed:!completed
                }
            }
            return el
        }))
    }
    return(
        <div>
            <li>
                {text}
            </li>
            <button onClick={completeHandler}>Check</button>
            <button onClick={deleteHandler}>Delete</button>
        </div>
    );
}

export default Todo;
```


### Styling
This tutorial assumes you know CSS, so I have included the entire CSS here: 
```css
body{
    background-color: rgb(72, 72, 247);
    font-size: 1.2rem;
    max-width: 100vw;
    max-height: 100vh;
}


input{
    padding:1.3rem 5rem;
    border:none;
    font-size: 1.1rem;
}
.add-btn{
    padding: 1.3rem;
    font-size: 1.1rem;
}

button{
    border:none;
    margin-right: 5px;

}


button:hover{
    transform: scale(0.98);
    transition: linear 0.8s;
    cursor: pointer;
}
.checked{
    color:rgb(240, 240, 247);
    text-decoration: line-through;
}
.todo{
    display: flex;
}

.check-btn{
    color:rgb(14, 14, 14);
    background-color: rgb(95, 130, 245);
}
.delete-btn{
    color: rgb(247, 238, 242);
    background-color: rgb(255, 38, 38);
}
```


### The App so far
Your app so far should look like this:
<br>

![React-PWA-image](/engineering-education/react-pwa/react-pwa1.png)
![React-PWA-image2](/engineering-education/react-pwa/react-pwa2.png)
<br>

### Adding functionality to make it a PWA
In this part, we will now convert our application into a progressive
web App.
A progressive web app refers to an enhanced web application having the same capabilities
as a native platform-specific application.
Our application will add functionalities such as running the application offline, caching assets by registering
service workers, and also installing it on the user's device screen.
<br>

### Register a service worker
A service worker is a script that is run by the browser in background off the main thread. 
It is responsible for requests and intercepts as well as managing caching for offline availability.
Inside our `public` folder, open the index.html. You need to put this inside scripts tag, now paste the following script:

```javascript
      if("serviceWorker" in navigator){
        window.addEventListener("load",()=>{
          navigator.serviceWorker.register('./serviceworker.js')
          .then(registration=>console.log('Success',registration.scope))
          .catch(err=>console.log("Error",err))
        })
      }
```
In the above code, we are checking if our browser supports service workers and registering a 
service worker file named `serviceworker.js` if the condition is true.

Go ahead and create the file `serviceworker.js` inside your `public` directory. This will have our custom code
for a service worker.
The `serviceworker.js` file will have the following code.

```javascript
const CACHE_NAME="version-1"
const urlsToCache=[" index.html","offline.html"]

const self=this;
// istall sw
self.addEventListener("install",(e)=>{
    e.waitUntil(
        caches.open(CACHE_NAME)
        .then((cache)=>{
            console.log("Opened cache...")
            return cache.addAll(urlsToCache)
        })
    )
})
// listen req
self.addEventListener("fetch",(e)=>{
        e.respondWith(
            caches.match(e.request)
                    .then(()=>{
                        return fetch(e.request)
                                .catch(()=>caches.match('offline.html'))
                    })
        )
})
// activate sw
self.addEventListener("activate",(e)=>{
    const cacheWhitelist=[]
    cacheWhitelist.push(CACHE_NAME);

    e.waitUntil(
        caches.keys().then((cacheNames)=>Promise.all(
            cacheNames.map((cacheName)=>{
                if(!cacheWhitelist.includes(cacheName)){
                    return caches.delete(cacheName)
                }
            })
        ))
    )
})
```
The `CACHE_NAME` variable will help us fetch resources from the `CACHE`.
The above code will now cache and fetch URL from our cache if we are offline. The `offline.html` file is used as the fallback markup file when no cache and the user is offline.
We defined three events: The fetch event is used in the installation of the service worker.
Our second event will be listening for network requests while the third is used to activate the service worker.
The self, which is JavaScript this keyword of the global service worker itself. Check the code above.

### The Public folder
The public folder currently has this structure:
```bash
    favicon.ico
    index.html
    logo192.png
    logo512.png
    manifest.json
    robots.txt
```
The `favicon.ico`, `logo192.png`, and `logo512.png` are icons that the user sees on the tab of mobile
or desktop devices. The browser will select by size depending on the device.
I will use these icons but one would as well use custom ones, feel free to try them out.
The robots.txt is for web crawlers for search engines and indexing which I will not be editing in this tutorial.

### Editing index.html file and Manifest
Manifest is a JSON file that has metadata to describe how the app will appear to the user.
We then link it to the HTML in line 18 of `index.html`:
```HTML
<link rel="manifest" href="./manifest.json" />
```
In our `manifest.json` file, the code contains icons that are applied as images of different sizes
on the home screen. The name, theme color, as well as the start URL, will live in this file.
```JSON
{
  "short_name": "React PWA",
  "name": "A React Todo PWA",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#F4BD42",
  "background_color": "#2B2929",
  "scope":"/"
}

```

Now, we need to edit the `index.html` file to have this changes in our manifest file.
Note there is nothing much is in our body tag in html file as our app was built with React and injected with JavaScript.
The `index.html` file now looks like:
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Todo Web App on PWA"
    />
    <link rel="apple-touch-icon" href="./logo192.png" />
    <link rel="manifest" href="./manifest.json" />
    <title>React Todo PWA</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
        <script>
      if("serviceWorker" in navigator){
        window.addEventListener("load",()=>{
          navigator.serviceWorker.register('./serviceworker.js')
          .then(registration=>console.log('Success',registration.scope))
          .catch(err=>console.log("Error",err))
        })
      }
    </script>
  </body>
</html>
```
We have just changed the title to React Todo PWA and the description of our app to Todo Web App on PWA.
Pointed apple-touch icon to the `logo192.png` and made our icon the `favicon.ico`.
All this now need to be added in the `manifest.json` file

### Performance of the App
I use lighthouse to generate audit report, the result is as follows:
The score is 89/100 which is fair considering this was about introducing PWA rather than production optimized.
Note that this will not pass the HTTPS audit in the development environment. So if hosting is needed, make sure the production web-server supports HTTPS.
Here is the final version of the App:


![PWA Performance](/engineering-education/react-pwa/performance.png)
![PWA install](/engineering-education/react-pwa/install.png)
![Requirements for PWA](/engineering-education/react-pwa/requirements.png)
Our app is now installable by clicking the plus icon on chrome.
The cache will make it available for offline use.

### Summary
In summary, we learned how to create a Todo app using the React library, with awesome features such as React Hooks and functional components. We created a Form input and functionality to add todo tasks, mark them as complete and delete the todo tasks. We then explored some introduction to Progressive Web Apps and turned our Todo app into a PWA.