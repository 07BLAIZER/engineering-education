### Introduction
In this tutorial, we are going to create a new React Todo application and turn it into a 
progressive web app (PWA). A progressive web app refers to an enhanced web application having the same capabilities
as a native platform-specific application by utilizing the emerging browser APIs. They are intended to be fast, reliable
and engaging.

### Prerequisites
1. Knowledge of the [JavaScript programming language](https://www.w3schools.com/js/DEFAULT.asp).
2. Basics of React library.Check documentation [here](https://www.reactjs.org).
3. A basic knowlegde of [NPM](https://www.npmjs.com/).
4. A code editor, I will be using [VS Code](https://code.visualstudio.com/download)


### Getting started
First, you should have Node.js installed on your computer. You can download the latest version [here](https://www.nodejs.org). The installed version of Node.js runtime comes pre-installed with a node.js package manager(npm).

To confirm that Node.js has been installed, open the terminal and execute the below command:
```bash
    node --version
```
This shows the version of Node.js running on your system confirming that Node.js has been installed.

Execute the command below to verify if npm is setup and ready for use.
```bash
    npm --version
```
First, we now need to create a new React application using the boilerplate code generated by the
create-react-app commandline utility. On your terminal, execute the following command:
```bash
    npx create-react-app react-pwa
```
This will create a folder named react-pwa. You can now open the project in your favourite code editor.
The folder structure will initially look similar to this:

```bash
node_modules/
public/
|--- favicon.ico
|--- index.html
|--- logo192.png
|--- manifest.json
|--- robots.txt
src/
|--- App.js
|--- App.css
|--- App.test.js
|--- index.js
|--- index.css
|--- serviceWorker.js
|--- logo.svg
.gitignore
package.json
README.md
yarn.lock
```
Our React code will be in the `src` folder. Inside this folder, 
go ahead and delete the `logo.svg` and remove everything in both `App.css` and `App.js` files.


### Creating UI components
Using React means that we will have to break our application into components that represent the 
logical parts of the UI.
We shall have four functional components.
1. App component
2. Form component
3. Todo component
4. TodoList component

### Form component
This is the component that will be used to add new todos.
In your `src/` folder, create a new folder named `components`. Inside the `components` folder, you need to create a file named `Form.js`. 
This is the code for the *Form.js*:

```javascript
import React,{useState} from 'react';
import {v4 as uuidv4} from 'uuid';

const Form =({addTodo})=>{
    
    const [inputText,setInputText]=useState("");

    const inputTextHandler=(e)=>{
        setInputText(e.target.value);
    }
    const submitTodoHandler=(e)=>{
        e.preventDefault();
        if(!inputText){
            return
        }
        addTodo({text:inputText,completed:false,id:uuidv4()});
        setInputText("");
    }

    return(
        <form onSubmit={submitTodoHandler}>
            <input type="text" value={inputText} placeholder="Add Todo" onChange={inputTextHandler}/>
            <button type="submit" className="add-btn">
                Add
            </button>
        </form>
    );
};

export default Form;
```

The code above uses functional components alongside React hooks. Hooks are functions that let you have state and other lifecycle patterns from function components.
We are using `useState` hook which returns two values in an array. The first value is the state, and the second value is the function to update the state. We have named the destructured values as `inputText` and `setInputText`.
Inside the form, we are binding the input tag to an event. On change of form state, The method `inputTextHandler` is invoked and updates the state to the current input value by calling the `setInputText` function.
The form is a controlled component that will track the `inputText`. We bind the form submission event with a method named `submitTodoHandler` that will call `addTodo` function when the event is triggered by clicking the *Add* button. The `addTodo` was passed down as props from the `App` component. The `setInputText` inside the `submitTodoHandler` will simply reset the form.
We now need to add this component in our parent `App` component and pass the function `addTodo` to it.
Below is the `App.js` file.
```javascript
import React,{useState} from 'react';

import Form from './components/Form';

const App=()=>{

  const addTodo= todo=>{
          const newTodos=[todo,...todos];
           setTodos(newTodos);
       }
  
  return (
    <div>
      <h1>TODO PWA</h1>
      <Form addTodo={addTodo}/>
    </div>
  );
}

export default App;
```

### Creating the TodoList and Todo Components
You need to create a new file named `TodosList.js` inside the components folder.
This is the component that acts as container to the list of the todo items.
The state is held in the App component and passed to the TodoList as props.
Before creating the TodoList component, the App component has its state, so below is the entire code for the `App.js` file:
A Todo component will represent a single todo item for each row. On the left will be the text and the right side of it will be the button to mark it 
as completed and a button to delete it. The TodoList will be the container for the list of todos available.
Since our Todo component is a child of the TodoList component, We will first create the TodoList component.
First, we need to add todos state inside the `App.js` file. So we will add extra props to the Form component.
The todos state is [lifted up](https://reactjs.org/docs/lifting-state-up.html) in the App component so that our `TodoList` will recieve it via the props pattern.
The `App.js` file is now as follows:

```javascript
import React,{useState} from 'react';

import Form from './components/Form';
import TodoList from './components/TodoList';

const App=()=>{

  const [todos,setTodos]=useState([]);

  const addTodo= todo=>{
          const newTodos=[todo,...todos];
           setTodos(newTodos);
       }
  
  return (
    <div>
      <h1>TODO PWA</h1>
      <Form addTodo={addTodo}/>
      <TodoList todos={todos} setTodos={setTodos}/>
    </div>
  );
}

export default App;
```

The todo will be an object with a structure like:
```javascript
    {
      id:v4(),
      task,
      complete:false
    }
```    
The id is a unique identifier or key for a specific todo task. I am using `uuid` libary to generate a unique id.
You can install the `uuid` library by executing the following command in your terminal:
```bash
npm install uuid
```
### The TodoList Component
The `TodoList` is recieving `todos` with array of objects as the todos and  while `setTodos` will be used to update the todos.
Using destructuring we grab all props in the `TodoList` component. We now need to create this `TodoList`.

Go in your components folder and create a new file named `TodoList.js`.
This `TodoList` component code is below:
```javascript
import React from "react";
import Todo from "./Todo";

const TodoList = ({ todos, setTodos }) => {
  const completeTodo = (id) => {
      let updatedTodos=todos.map(todo=>{
          if(todo.id===id){
              todo.completed=!todo.completed;
          }
          return todo;
      })
      setTodos(updatedTodos);
  };
  const removeTodo=(id)=>{
    setTodos(todos.filter(todo=>todo.id!==id));
  }

  return (
    <div className="todo-container">
      <ul className="todo-list">
        {todos.map((todo) => (
          <Todo key={todo.id}
            todo={todo}
            completeTodo={completeTodo} 
            removeTodo={removeTodo}/>
        ))}
      </ul>
    </div>
  );
};

export default TodoList;
```

To create a todo, we are mapping through the todos and returning a new Todo component as the todo item.
The `removeTodo` passes an `id` to uniquely identify the `todo` in our list. Whatever todos that do not match the provided `id` are filtered and stored in the state using `setTodos`.
We will use `completeTodo` method to toggle the state of the completed property state and apply a strike-through if the component is marked as complete. This boolean will be used to apply the appropiate class in our styles.
Let us now create the `Todo` component.

### The Todo component
You need to add a new file and name it `Todo.js` in the components folder.
We created the functions that perform the complete and delete operations in our `TodoList` component. We now need to destructure
the props and bind them to the *Check* button for completed tasks and *Delete* buttons.
Clicking the the *Check* button will invoke the `HandleComplete` that will call the function `completeTodo` passing the `id`.
The `HandleDelete` method will call the function `removeTodo` and filter out the todo by its `id`.
Check the code below:

```javascript
import React from 'react';

const Todo=({todo,completeTodo,removeTodo})=>{
    
    const HandleComplete=()=>{
        completeTodo(todo.id);
    }
    const HandleDelete=()=>{
        removeTodo(todo.id);
    }

    return(
        <div>
            <div className="todo">
            <li className={todo.completed?"checked":""}>
                {todo.text}
            </li>
            <button onClick={HandleComplete} className="check-btn">{todo.completed?"Uncheck":"Check"}</button>
            <button className="delete-btn" onClick={HandleDelete}>Delete</button>
            </div>
        </div>
    );
}

export default Todo;
```

### Styling
This tutorial assumes you know basics of CSS styling, so I have some basic styles here: 
```css
body{
    background-color: rgb(72, 72, 247);
    font-size: 1.2rem;
    max-width: 100vw;
    max-height: 100vh;
}

input{
    padding:1.3rem 5rem;
    border:none;
    font-size: 1.1rem;
}
.add-btn{
    padding: 1.3rem;
    font-size: 1.1rem;
}

button{
    border:none;
    margin-right: 5px;

}

button:hover{
    transform: scale(0.98);
    transition: linear 0.8s;
    cursor: pointer;
}
.checked{
    color:rgb(240, 240, 247);
    text-decoration: line-through;
}
.todo{
    display: flex;
}

.check-btn{
    color:rgb(14, 14, 14);
    background-color: rgb(95, 130, 245);
}
.delete-btn{
    color: rgb(247, 238, 242);
    background-color: rgb(255, 38, 38);
}
```


### The App so far
Your app so far should look like this:

![React-PWA-image](/engineering-education/react-pwa/react-pwa1.png)
![React-PWA-image2](/engineering-education/react-pwa/react-pwa2.png)


### Adding functionality to make it a PWA
In this part, we will now convert our application into a progressive
web App.
Our application will add functionalities such as running the application offline, caching assets by registering
service workers, and also installing it on the user's device screen.


### Register a service worker
A service worker is a script that is run by the browser in background off the main thread. 
It is responsible for network intercepts from requests as well as managing caching for offline availability.
This is where we need to focus on that `public` folder.
Inside our `public` folder, open the index.html file. 
Below the file, add the following code. You need to put this inside a script tag.

```javascript
      if("serviceWorker" in navigator){
        window.addEventListener("load",()=>{
          navigator.serviceWorker.register('./serviceworker.js')
          .then(registration=>console.log('Success',registration.scope))
          .catch(err=>console.log("Error",err))
        })
      }
```
In the above code, we are checking if our browser supports service workers.
If this returns true, we will go ahead and register a service worker that points to the file named `serviceWorker.js`. 
Now our service worker is registered in the background and we need to create it. Go ahead and create the file `serviceworker.js` inside your `public` directory.
The `serviceworker.js` file will have the following code.

```javascript
const CACHE_NAME="version-1"
const urlsToCache=[" index.html","offline.html"]

const self=this;
// istall sw
self.addEventListener("install",(e)=>{
    e.waitUntil(
        caches.open(CACHE_NAME)
        .then((cache)=>{
            console.log("Opened cache...")
            return cache.addAll(urlsToCache)
        })
    )
})
// listen req
self.addEventListener("fetch",(e)=>{
        e.respondWith(
            caches.match(e.request)
                    .then(()=>{
                        return fetch(e.request)
                                .catch(()=>caches.match('offline.html'))
                    })
        )
})
// activate sw
self.addEventListener("activate",(e)=>{
    const cacheWhitelist=[]
    cacheWhitelist.push(CACHE_NAME);

    e.waitUntil(
        caches.keys().then((cacheNames)=>Promise.all(
            cacheNames.map((cacheName)=>{
                if(!cacheWhitelist.includes(cacheName)){
                    return caches.delete(cacheName)
                }
            })
        ))
    )
})
```
We are starting with the install step. At this step, we are trying to cache some static assets that will be available
offline. This returns a promise, when all are cached, the registered service worker becomes installed.
The activate listener is where we manage our old caches. 
The `CACHE_NAME` variable will help us fetch resources from the cache.
The above code will now cache and fetch the URL from our cache if we are offline. The offline.html file is used as the fallback markup file when there is no cache and the user is offline.
We defined three events: The fetch event is used in the installation of the service worker.
Our second event will be listening for network requests while the third is used to activate the service worker.
The self, which is JavaScript this keyword of the global service worker itself. Check the code above.

### The Public folder
The public folder currently has this structure:
```bash
    favicon.ico
    index.html
    logo192.png
    logo512.png
    manifest.json
    robots.txt
```
The `favicon.ico`, `logo192.png`, and `logo512.png` are icons that the user sees on the tab of mobile
or desktop devices. The browser will select by size depending on the device.
I will use these icons but one would as well use custom ones, feel free to try them out.
The robots.txt is for web crawlers for search engines and indexing which I will not be editing in this tutorial.

### Editing index.html file and Manifest
Manifest is a JSON file that has metadata to describe how the app will appear to the user.
We then link it to the HTML in line 18 of `index.html`:
```HTML
<link rel="manifest" href="./manifest.json" />
```
In our `manifest.json` file, the code contains icons that are applied as images of different sizes
on the home screen. The name, theme color, as well as the start URL, will live in this file.
```JSON
{
  "short_name": "React PWA",
  "name": "A React Todo PWA",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#F4BD42",
  "background_color": "#2B2929",
  "scope":"/"
}

```

Now, we need to edit the `index.html` file to have this changes in our manifest file.
Note there is nothing much is in our body tag in html file as our app was built with React and injected with JavaScript.
The `index.html` file now looks like:
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Todo Web App on PWA"
    />
    <link rel="apple-touch-icon" href="./logo192.png" />
    <link rel="manifest" href="./manifest.json" />
    <title>React Todo PWA</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
        <script>
      if("serviceWorker" in navigator){
        window.addEventListener("load",()=>{
          navigator.serviceWorker.register('./serviceworker.js')
          .then(registration=>console.log('Success',registration.scope))
          .catch(err=>console.log("Error",err))
        })
      }
    </script>
  </body>
</html>
```
We have just changed the title to React Todo PWA and the description of our app to Todo Web App on PWA.
Pointed apple-touch icon to the `logo192.png` and made our icon the `favicon.ico`.
All this now need to be added in the `manifest.json` file

### Performance of the App
I use lighthouse to generate audit report, the result is as follows:
The score is 89/100 which is fair considering this was about introducing PWA rather than production optimized.
Note that this will not pass the HTTPS audit in the development environment. So if hosting is needed, make sure the production web-server supports HTTPS.
Here is the final version of the App:


![PWA Performance](/engineering-education/react-pwa/performance.png)
![PWA install](/engineering-education/react-pwa/install.png)
![Requirements for PWA](/engineering-education/react-pwa/requirements.png)

Our app is now installable by clicking the plus icon on chrome.
The cache will make it available for offline use.

### Summary
In summary, we learned how to create a Todo app using the React library, with awesome features such as React Hooks and functional components. We created a Form input and functionality to add todo tasks, mark them as complete and delete the todo tasks. We then explored some introduction to Progressive Web Apps and turned our Todo app into a PWA.