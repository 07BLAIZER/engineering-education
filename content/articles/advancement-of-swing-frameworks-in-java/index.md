### Advancement of Swing Frameworks in Java
         
 Swing Framework was included as part of the Java Foundation Classes (JFC). Swing Framework was originally available to be utilized with Java 1.1 as a distinct library. However, originally in Java 1.2, Swing became fully integrated into Java language.
**Framework** can raise concerns because frameworks can be large and complicated. When we consider small applications, a spring framework can bring about more difficulty than the original system it supposedly improves. However, the Swing  Framework has goals that reduce any troublesome effects that a larger framework could cause.
 
The framework has a basic objective  to provide the kernel of a  Swing application model, assisting programmers to get started swiftly and to acquire optimum practices for just a few elements related to every Swing Framework.
### Table of contents
-  [Prerequisites](#prerequisites)
-  [Swing Supports a Pluggable Look and Feel](#swing-supports-a-pluggable-look-and-feel)
- [The MVC Connection](#the-mvc-connection)
- [Event Handling](#event-handling)
- [Performing  Swing Painting ](#performing-swing-painting)
- [Conclusion](#conclusion)


### Prerequisites

To follow along, you must:

1.  Be familiar with java programming language.
2.  Be familiar with introduction to java swing. Refer to this article to  [introduction to java swing](https://www.section.io/engineering-education/introduction-to-java-swing/)

### Swing Supports a Pluggable Look and Feel
  
Swing supports a pluggable look and feel (PLAF). Since each Swing component is considered by Java code. The look creates an aesthetic feeling and a component is under the control of Swing. This fact means that you can separate the look and feel of a component from the logic of the component  since this is what Swing does. It is possible to “plug in” an unused look and feel for any given component with failure to create any side effects in the code that uses that component. Pluggable look-and-feel provide numerous important benefits. It is practical to explain a look and feel that is consistent across all platforms. That is, suppose an application will be running  in a MacOS environment only, it is possible to specify the MacOS look and feel. It is also possible to model the convention look and feel. To summarize, the look and feel can be changed dynamically at run time.

### The MVC Connection
Although the MVC design and ideas that underpin the **Swing Framework** are ideal, the high level of separation between the view and the controller is problematic for Swing components. Swing, on the other hand, employs a modified form of MVC that combines view and controller binding into a single logical object known as the UI delegate. The Separable Model architecture or the Model-Delegate architecture are the two approaches used by Swing. Although the component architecture of Swing's Framework is based on MVC, it does not employ a traditional implementation. Model-Delegate architecture shapes and realizes Swing's pluggable look and feel.

### Event Handling
**Swing Framework** components respond to user input as well as events generated by the interactions to be handled. When a timer goes off, for example, an event is triggered. In any case, event handling is an important part of any Swing-based application. In most cases, Swing uses the same events as AWT, and the deployment of these events is packaged in *java.awt.event*. The *java.swing.event* stores only Swing-specific events. The event generated by a Swing Framework push button is managed by the program below, illustrated by code.
```java
// Event handler in a Swing program.
package eventdemo;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
class EventDemo {
 JLabel jlab;
  // We will be forming a JFrame repository.
 EventDemo() {
JFrame jfrm = new JFrame("EVENT HANDLER ILLUSTRATOR");
 // We will be specifying the  FlowLayout for the layout manager.
 jfrm.setLayout(new FlowLayout());
 // At this point we have to assign our frame a primary size.
 jfrm.setSize(400, 400);
 // When the user closes the application, the program should stop.
 jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 // You can create as many buttons but here we are going create only two.
 JButton jbtnEvent1 = new JButton("Event1");
 JButton jbtnEvent2 = new JButton("Event2");
 // Implementing Event1 listener.
 jbtnEvent1.addActionListener(new ActionListener() {
 // Declaring ActionPerformed to be visible to all classes.
 public void actionPerformed(ActionEvent ae) {
 jlab.setText("EVENT1 HAS BEEN HANDLED." + "\n");
 }
 });
 // Add action listener for Event2.
 jbtnEvent2.addActionListener(new ActionListener() {
 public void actionPerformed(ActionEvent ae) {
 jlab.setText("EVENT2 HAS BEEN HANDLED." + "\n");
 }
 });
 // Put the buttons to the content pane.
 jfrm.add(jbtnEvent1);
 jfrm.add(jbtnEvent2);
 // text-based label will have to be created.
 jlab = new JLabel("Press any button.");
 // Putting labels.
 jfrm.add(jlab);
 //Putting the frame on display.
 jfrm.setVisible(true);
 }
 public static void main(String args[]) {
//This metod uses Swing for its user interface.
 SwingUtilities.invokeLater(new Runnable() {
 public void run() {
 new EventDemo();
 }
 });
 }
}
```
When you run your program the first output gotten is this:
![Button](/engineering-education/advancement-of-swing-frameworks-in-Java/button.png)

when you click the first button you get the display as shown below:
![Event1](/engineering-education/advancement-of-swing-frameworks-in-Java/event1.png)

When you click the second button  you get the output display as shown below:
![Event2](/engineering-education/advancement-of-swing-frameworks-in-Java/event2.png)

### Performing Swing Painting 
**Swing Framework** is very powerful, you are not restricted to using it since Swing Framework also enables users to write directly into the display area of the frame, panel, or other components of swing, such as JLabel. However,  numerous uses of Swing will not require direct drawing  to the component's surface , it is availability depends on those applications that require this functionality. To  directly write in the given output to the surface of a component, you will have to use the drawing procedures defined in the AWT library, such as drawRect( ) or the drawLine( ) method.

```java
// Painting to the panel lines.
package paintdemo;
import java.awt.*;
import javax.swing.*;
import java.util.*;
//  In the panel lines are plotted.
class PaintPanel extends JPanel {
 Insets ins; // Insets acts as the panel holder
 Random rand; // Generation of random numbers
 // Construction of the panel.
 PaintPanel() {
 //Placing a border around the panel gives yuor platform a neat view.
 setBorder(
 //Defining the border shade
 BorderFactory.createLineBorder(Color.GREEN, 5));
 //An object for random outputs is created.
 rand = new Random();
 }
 // PaintComponent() function needs to be overriden.
 @Override
 protected void paintComponent(Graphics j) {
 // You will have to call the superclass method first.
 super.paintComponent(j);
 int a, b, a2, b2;
 // Get the Dimensions of the component.
 int height = getHeight();
 int width = getWidth();
 // Getting the insets.
 ins = getInsets();
 // Draw nine lines whose endpoints are generated randomly .
 for(int i=0; i < 9; i++) {
 // At this point we will be acquiring random coordinates.
 a = rand.nextInt(width-ins.left);
 b = rand.nextInt(height-ins.bottom);
 a2 = rand.nextInt(width-ins.left);
 b2 = rand.nextInt(height-ins.bottom);
 // Drawing of the lines.
 j.drawLine(a, b, a2, b2);
 }
 }
}
// illustrating how painting is right away carried out onto the panel.
 public class PaintDemo {
 JLabel jlab;
 PaintPanel jj;
 PaintDemo() {
 // Formation of a new JFrame repository.
 JFrame jfrm = new JFrame("Paint Demo");
 // The frame require's an initial size.
 jfrm.setSize(400, 400);
 // End the program if the user happens to close the swing application.
 jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 // Creation of the panel that will need painting.
 jj = new PaintPanel();
 jfrm.add(jj);
 // Showing the display .
 jfrm.setVisible(true);
 }
 public static void main(String args[]) {
 // Thread event execution are created in relation to the frame.
 SwingUtilities.invokeLater(() -> {
     PaintDemo paintDemo = new PaintDemo();
 });
 }
}
```
![Painting](/engineering-education/advancement-of-swing-frameworks-in-Java/painting.png)

In order to manage painting, PaintPanel overrides the paintComponent( ) function. This enables PaintPanel to directly  write to the surface of the component while painting occurs. The size of the panel is not defined as the program uses the default border format and the panel is added towards the middle. This output in the panel is sized to fill the middle.

### Conclusion

In this article, you have gained insights for using swing frameworks to:
##### 1. Handle events.
#####  2. Painting in the panel.
##### 3. Understanding how swing Supports a Pluggable Look and Feel.
##### 4. Understanding the concept of MVC.
 Moreover, you are also equipped with the necessary information to handle swing frameworks entirely.
You are now a swing expert, untroubled coding!


