Spring Batch is a lightweight, open-source framework created to develop scalable batch processing applications. Batch processing is majorly used by applications that process a large quantity of data at a given time, i.e the payroll systems use batch processing to send out payments to employees at a given time of the month.
Spring Batch does not include an inbuilt scheduling framework. It can be used with Quartz or Control-M scheduling frameworks to process data at a scheduled time.

In this tutorial, we are going to develop a Spring Boot application that reads data from a CSV file and stores the data in a SQL database (H2 database).

### Table of Contents
- [Table of Contents](#table-of-contents)
- [Prerequisites](#prerequisites)
- [Application setup](#application-setup)
- [Domain](#domain)
- [Testing](#testing)
- [Conclusion](#conclusion)

### Prerequisites
1. Java Development kit[JDK](https://www.oracle.com/java/technologies/javase-downloads.html) installed on your computer.
2. Some knowledge in [Spring Boot](https://spring.io/guides).


### Application setup
1. On your browser, navigate to [spring intializr](https://start.spring.io/).
2. Set the project name as `springbatch`.
3. Add `lombok`, `spring web`, `h2 database`, `spring data jpa`, and `spring batch` as the project dependencies.
4. Click on generate button to download the project zip file.
5. Unzip the downloaded project file and open it in your favorite IDE.

### Domain
1. In the root project package, create a package named `domain`.
2. In the `domain` package created above, create a file named `Person` and add the code snippets below to it.
   ```java
    @Entity(name = "person")
    @Getter // Lombok annotation to generate Getters for the fields
    @Setter // Lombok annotation to generate Setters for the fields
    @AllArgsConstructor // Lombok annotation to generate a constructor will all of the fields in the class
    @NoArgsConstructor // Lombok annotation to generate an empty constructor for the class
    @EntityListeners(AuditingEntityListener.class)
    public class Person {
        @Id // Sets the id field as the primary key in the database table
        @Column(name = "id") // sets the column name for the id property
        @GeneratedValue(strategy = GenerationType.AUTO) // States that the id field should be autogenerated
        private Long id;

        @Column(name = "last_name")
        private String lastName;
        @Column(name = "first_name")
        private String firstName;

        // A method that returns firstName and Lastname when an object of the class is logged
        @Override
        public String toString() {
            return "firstName: " + firstName + ", lastName: " + lastName;
        }

    }
    ```
The above class has an `id` field for the primary field in the database, `lastName` and `firstName` fields that we will get from the `sample-data.csv` file.

### Repository
1. In the root project package, create a new package named `repositories`.
2. In the `repositories` package created above, create an interface named `PersonRepository` and add the code snippet below.
    ```java
    // The interface extends JpaRepository that has the CRUD operation methods
    public interface PersonRepository extends JpaRepository<Person, Long> {

    }

    ```

### Processor
1. In the root project package, create a new package named `processor`.
2. In the `processor` package, create a new Java file named `PersonProcessor`, add the code snippets below.

    ```java
    public class PersonProcessor implements ItemProcessor<Person, Person> {
        // Creates a logger 
        private static final Logger logger = LoggerFactory.getLogger(PersonProcessor.class);

        // This method transforms data form one form to another.
        @Override
        public Person process(final Person person) throws Exception {
            final String firstName = person.getFirstName().toUpperCase();
            final String lastName = person.getLastName().toUpperCase();
            // Creates a new instance of Person
            final Person transformedPerson = new Person(1L, firstName, lastName);
            // logs the person entity to the application logs
            logger.info("Converting (" + person + ") into (" + transformedPerson + ")");

            return transformedPerson;
        }

    }
    ```
The above class transforms data from one form to another. The `ItemProcessor<I, O>`  takes in the input `I` data, transforms it, and returns it as the output data `O`. In our case, we have declared the `Person` entity as both the input and output, meaning our data form is maintained.

### Configuration
1. Create a new package named `config` in the roor projet package. This package will contain all of our configurations.
2. In the `config` package created above, create a new Java file named `BatchConfiguration` and add the code snippets below.

    ```java
    @Configuration //  Informs Spring that this class contains configurations
    @EnableBatchProcessing // Enables batch processing for the application
    public class BatchConfiguration {

        @Autowired
        public JobBuilderFactory jobBuilderFactory;

        @Autowired
        public StepBuilderFactory stepBuilderFactory;

        @Autowired
        @Lazy
        public PersonRepository personRepository;

        //  Reads the sample-data.csv file and creates instances of the Person entity for each person from the .csv file.
        @Bean
        public FlatFileItemReader<Person> reader() {
            return new FlatFileItemReaderBuilder<Person>()
                    .name("personReader")
                    .resource(new ClassPathResource("sample-data.csv"))
                    .delimited()
                    .names(new String[]{"firstName", "lastName"})
                    .fieldSetMapper(new BeanWrapperFieldSetMapper<Person>() {{
                        setTargetType(Person.class);
                    }})
                    .build();
        }

        // Creates the Writer, configuring the repository and the method that will be used to save the data into the database
        @Bean
        public RepositoryItemWriter<Person> writer() {
            RepositoryItemWriter<Person> writer = new RepositoryItemWriter<>();
            writer.setRepository(personRepository);
            writer.setMethodName("save");
            return writer;
        }

        // Creates an instance of PersonProcessor that converts one data form to another. In our case the data form is maintained.
        @Bean
        public PersonProcessor processor() {
            return new PersonProcessor();
        }

        // Batch jobs are built from steps. A step contains the reader, processor and the writer.
        @Bean
        public Step step1(ItemReader<Person> itemReader, ItemWriter<Person> itemWriter)
                throws Exception {

            return this.stepBuilderFactory.get("step1")
                    .<Person, Person>chunk(5)
                    .reader(itemReader)
                    .processor(processor())
                    .writer(itemWriter)
                    .build();
        }
        // Executes the job, saving the data from .csv file into the database.
        @Bean
        public Job personUpdateJob(JobCompletionNotificationListener listener, Step step1)
                throws Exception {

            return this.jobBuilderFactory.get("personUpdateJob").incrementer(new RunIdIncrementer())
                    .listener(listener).start(step1).build();
        }

    }
    ```
3. In the `config` package, create a new Java class named `JobCompletionNotificationListener` and add the code snippets below.

    ```java
    @Component
    public class JobCompletionNotificationListener extends JobExecutionListenerSupport {
        // Creates an instance of the loggger
        private static final Logger log = LoggerFactory.getLogger(JobCompletionNotificationListener.class);
        private final PersonRepository personRepository;

        @Autowired
        public JobCompletionNotificationListener(PersonRepository personRepository) {
            this.personRepository = personRepository;
        }

        // The callback method from the Spring Batch JobExecutionListenerSupport class that is executed when the batch process is completed
        @Override
        public void afterJob(JobExecution jobExecution) {
            // When the batch process is completed the the users in the database are retrieved and logged on the application logs
            if (jobExecution.getStatus() == BatchStatus.COMPLETED) {
                log.info("!!! JOB FINISHED! Time to verify the results");
                personRepository.findAll()
                        .forEach(person -> log.info("Found <" + person + "> in the database.") );
            }
        }
    }
    ```

### Controller
1. In the root project package, create a new package named `controllers`.
2. In the `controllers` package created above, create a Java class named `BatchController` and add the code snippet below.

    ```java
    @RestController
    @RequestMapping(path = "/batch")// Root path
    public class BatchController {
        @Autowired
        private JobLauncher jobLauncher;
        @Autowired
        private Job job;

        // The function below accepts a GET request to invoke the Batch Process and returns a String as response with the message "Batch Process started!!".
        @GetMapping(path = "/start") // Start batch process path
        public ResponseEntity<String> startBatch() {
            JobParameters jobParameters = new JobParametersBuilder()
                    .addLong("startAt", System.currentTimeMillis()).toJobParameters();
            try {
                jobLauncher.run(job, jobParameters);
            } catch (JobExecutionAlreadyRunningException | JobRestartException
                    | JobInstanceAlreadyCompleteException | JobParametersInvalidException e) {

                e.printStackTrace();
            }
            return new ResponseEntity<>("Batch Process started!!", HttpStatus.OK);
        }
    }
    ```

### Application Configuration
In the resource directory, add the code snippet below to the `application.properties` file.

```yml
# Sets the server port from where we can access our application
server.port=8080
# Disables our batch process from automatically running on application startup
spring.batch.job.enabled=false

```

### Testing 
Open Postman and send a `GET` request to [http://localhost:8080/batch/start](http://localhost:8080/batch/start) to start the batch process.

![Postman GET request](/engineering-education/spring-boot-batch/batch-running.png)

After sending the `GET` request, we can see from the application logs the batch process running.

![Batch process running](/engineering-education/spring-boot-batch/batch-cmd.png)

### Conclusion
Now that you have learned how to execute batch processes in a Spring Boot application, configure the application we have developed in this tutorial to use Spring Boot Scheduler to Schedule jobs to run at a given time automatically rather than sending an HTTP call to start a job. You can download the complete source code [here](https://replit.com/@okeloviolet/SpringBatchProcessing#).
